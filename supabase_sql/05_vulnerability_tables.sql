-- =====================================================
-- ENHANCED VULNERABILITY SCANNER - SUPABASE SETUP
-- File 5: Vulnerability Management Tables
-- =====================================================
-- Run this file AFTER 04_scanning_tables.sql
-- This creates vulnerability detection, analysis, and management tables

-- =====================================================
-- VULNERABILITY TYPE AND CLASSIFICATION
-- =====================================================

-- Vulnerability types and categories
CREATE TABLE public.vulnerability_types (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    category vulnerability_category NOT NULL,
    subcategory VARCHAR(50),
    severity severity_level DEFAULT 'medium',
    cwe_id VARCHAR(20),
    owasp_category VARCHAR(50),
    description TEXT NOT NULL,
    impact_description TEXT,
    remediation_guidance TEXT,
    reference_links JSONB DEFAULT '[]'::jsonb,
    detection_rules JSONB DEFAULT '[]'::jsonb,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Vulnerability instances found during scans
CREATE TABLE public.vulnerabilities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID REFERENCES public.scan_sessions(id) ON DELETE CASCADE,
    vulnerability_type_id UUID REFERENCES public.vulnerability_types(id),
    url_id UUID REFERENCES public.discovered_urls(id),
    form_id UUID REFERENCES public.extracted_forms(id),
    title VARCHAR(200) NOT NULL,
    description TEXT NOT NULL,
    severity severity_level NOT NULL,
    confidence DECIMAL(3,2) DEFAULT 1.0 CHECK (confidence BETWEEN 0 AND 1),
    status vulnerability_status DEFAULT 'open',
    false_positive BOOLEAN DEFAULT false,
    verified BOOLEAN DEFAULT false,
    exploitable BOOLEAN DEFAULT false,
    impact_score DECIMAL(3,1) CHECK (impact_score BETWEEN 0 AND 10),
    likelihood_score DECIMAL(3,1) CHECK (likelihood_score BETWEEN 0 AND 10),
    cvss_score DECIMAL(3,1) CHECK (cvss_score BETWEEN 0 AND 10),
    cvss_vector VARCHAR(100),
    cwe_id VARCHAR(20),
    owasp_category VARCHAR(50),
    evidence JSONB DEFAULT '{}'::jsonb,
    proof_of_concept TEXT,
    remediation_advice TEXT,
    reference_links JSONB DEFAULT '[]'::jsonb,
    tags JSONB DEFAULT '[]'::jsonb,
    detected_at TIMESTAMPTZ DEFAULT NOW(),
    verified_at TIMESTAMPTZ,
    resolved_at TIMESTAMPTZ,
    verified_by UUID REFERENCES auth.users(id),
    resolved_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Detailed vulnerability instances with specific parameters
CREATE TABLE public.vulnerability_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID REFERENCES public.vulnerabilities(id) ON DELETE CASCADE,
    parameter_name VARCHAR(100),
    parameter_type VARCHAR(50),
    parameter_value TEXT,
    payload TEXT,
    request_method http_method DEFAULT 'GET',
    request_headers JSONB DEFAULT '{}'::jsonb,
    request_body TEXT,
    response_status INTEGER,
    response_headers JSONB DEFAULT '{}'::jsonb,
    response_body TEXT,
    response_time INTEGER,
    exploitation_difficulty VARCHAR(20) DEFAULT 'medium',
    business_impact VARCHAR(20) DEFAULT 'medium',
    technical_impact VARCHAR(20) DEFAULT 'medium',
    affected_users VARCHAR(20) DEFAULT 'some',
    data_sensitivity VARCHAR(20) DEFAULT 'medium',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- SECURITY ANALYSIS TABLES
-- =====================================================

-- SSL/TLS certificate analysis
CREATE TABLE public.ssl_certificates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    url_id UUID REFERENCES public.discovered_urls(id) ON DELETE CASCADE,
    domain VARCHAR(255) NOT NULL,
    port INTEGER DEFAULT 443,
    certificate_pem TEXT,
    subject VARCHAR(500),
    issuer VARCHAR(500),
    serial_number VARCHAR(100),
    signature_algorithm VARCHAR(50),
    public_key_algorithm VARCHAR(50),
    public_key_size INTEGER,
    valid_from TIMESTAMPTZ,
    valid_to TIMESTAMPTZ,
    is_expired BOOLEAN DEFAULT false,
    is_self_signed BOOLEAN DEFAULT false,
    is_wildcard BOOLEAN DEFAULT false,
    san_domains JSONB DEFAULT '[]'::jsonb,
    certificate_chain JSONB DEFAULT '[]'::jsonb,
    vulnerabilities JSONB DEFAULT '[]'::jsonb,
    trust_score DECIMAL(3,2) DEFAULT 1.0 CHECK (trust_score BETWEEN 0 AND 1),
    analyzed_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- DNS security analysis
CREATE TABLE public.dns_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain VARCHAR(255) NOT NULL,
    record_type VARCHAR(10) NOT NULL,
    record_value TEXT NOT NULL,
    ttl INTEGER,
    priority INTEGER,
    has_spf BOOLEAN DEFAULT false,
    has_dkim BOOLEAN DEFAULT false,
    has_dmarc BOOLEAN DEFAULT false,
    has_caa BOOLEAN DEFAULT false,
    security_issues JSONB DEFAULT '[]'::jsonb,
    analyzed_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(domain, record_type, record_value)
);

-- HTTP security analysis
CREATE TABLE public.http_security_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    url_id UUID REFERENCES public.discovered_urls(id) ON DELETE CASCADE,
    has_hsts BOOLEAN DEFAULT false,
    hsts_max_age INTEGER,
    hsts_include_subdomains BOOLEAN DEFAULT false,
    has_csp BOOLEAN DEFAULT false,
    csp_policy TEXT,
    csp_violations JSONB DEFAULT '[]'::jsonb,
    has_x_frame_options BOOLEAN DEFAULT false,
    x_frame_options_value VARCHAR(50),
    has_x_content_type_options BOOLEAN DEFAULT false,
    has_x_xss_protection BOOLEAN DEFAULT false,
    has_referrer_policy BOOLEAN DEFAULT false,
    referrer_policy_value VARCHAR(50),
    has_permissions_policy BOOLEAN DEFAULT false,
    permissions_policy TEXT,
    cookie_security JSONB DEFAULT '{}'::jsonb,
    cors_configuration JSONB DEFAULT '{}'::jsonb,
    security_score DECIMAL(3,2) DEFAULT 0.0 CHECK (security_score BETWEEN 0 AND 1),
    analyzed_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- VULNERABILITY TRACKING AND MANAGEMENT
-- =====================================================

-- Vulnerability comments and notes
CREATE TABLE public.vulnerability_comments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID REFERENCES public.vulnerabilities(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES public.vulnerability_comments(id) ON DELETE CASCADE,
    comment_type VARCHAR(20) DEFAULT 'comment',
    content TEXT NOT NULL,
    is_internal BOOLEAN DEFAULT false,
    attachments JSONB DEFAULT '[]'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Vulnerability assignments and ownership
CREATE TABLE public.vulnerability_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID REFERENCES public.vulnerabilities(id) ON DELETE CASCADE,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    assigned_by UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    assignment_reason TEXT,
    due_date TIMESTAMPTZ,
    priority INTEGER DEFAULT 5 CHECK (priority BETWEEN 1 AND 10),
    status VARCHAR(20) DEFAULT 'assigned',
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Vulnerability remediation tracking
CREATE TABLE public.vulnerability_remediations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_id UUID REFERENCES public.vulnerabilities(id) ON DELETE CASCADE,
    remediation_type VARCHAR(50) NOT NULL,
    description TEXT NOT NULL,
    implementation_steps TEXT,
    estimated_effort VARCHAR(20),
    actual_effort VARCHAR(20),
    cost_estimate DECIMAL(10,2),
    actual_cost DECIMAL(10,2),
    priority INTEGER DEFAULT 5 CHECK (priority BETWEEN 1 AND 10),
    status VARCHAR(20) DEFAULT 'planned',
    implemented_by UUID REFERENCES auth.users(id),
    verified_by UUID REFERENCES auth.users(id),
    planned_date TIMESTAMPTZ,
    implemented_date TIMESTAMPTZ,
    verified_date TIMESTAMPTZ,
    rollback_plan TEXT,
    success_criteria TEXT,
    verification_method TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- VULNERABILITY TRENDS AND ANALYTICS
-- =====================================================

-- Vulnerability trends over time
CREATE TABLE public.vulnerability_trends (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES public.projects(id) ON DELETE CASCADE,
    date_recorded DATE NOT NULL,
    total_vulnerabilities INTEGER DEFAULT 0,
    critical_count INTEGER DEFAULT 0,
    high_count INTEGER DEFAULT 0,
    medium_count INTEGER DEFAULT 0,
    low_count INTEGER DEFAULT 0,
    info_count INTEGER DEFAULT 0,
    new_vulnerabilities INTEGER DEFAULT 0,
    resolved_vulnerabilities INTEGER DEFAULT 0,
    false_positives INTEGER DEFAULT 0,
    verified_vulnerabilities INTEGER DEFAULT 0,
    avg_time_to_resolve DECIMAL(10,2),
    security_score DECIMAL(3,2) DEFAULT 0.0 CHECK (security_score BETWEEN 0 AND 1),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(project_id, date_recorded)
);

-- Vulnerability patterns and signatures
CREATE TABLE public.vulnerability_patterns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pattern_name VARCHAR(100) NOT NULL UNIQUE,
    pattern_type VARCHAR(50) NOT NULL,
    pattern_signature TEXT NOT NULL,
    vulnerability_type_id UUID REFERENCES public.vulnerability_types(id),
    detection_logic JSONB NOT NULL,
    confidence_threshold DECIMAL(3,2) DEFAULT 0.8,
    false_positive_rate DECIMAL(3,2) DEFAULT 0.1,
    is_active BOOLEAN DEFAULT true,
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- COMPLIANCE AND STANDARDS
-- =====================================================

-- Compliance frameworks and requirements
CREATE TABLE public.compliance_frameworks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    version VARCHAR(20),
    description TEXT,
    requirements JSONB NOT NULL DEFAULT '[]'::jsonb,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Compliance mapping for vulnerabilities
CREATE TABLE public.vulnerability_compliance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    vulnerability_type_id UUID REFERENCES public.vulnerability_types(id) ON DELETE CASCADE,
    framework_id UUID REFERENCES public.compliance_frameworks(id) ON DELETE CASCADE,
    requirement_id VARCHAR(50) NOT NULL,
    requirement_description TEXT,
    compliance_level VARCHAR(20) DEFAULT 'required',
    impact_on_compliance TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(vulnerability_type_id, framework_id, requirement_id)
);

-- =====================================================
-- CONSTRAINTS AND CHECKS
-- =====================================================

-- Vulnerability type constraints
ALTER TABLE public.vulnerability_types 
ADD CONSTRAINT vulnerability_types_name_length CHECK (char_length(name) >= 3);

-- Vulnerability constraints
ALTER TABLE public.vulnerabilities 
ADD CONSTRAINT vulnerabilities_title_length CHECK (char_length(title) >= 5);

ALTER TABLE public.vulnerabilities 
ADD CONSTRAINT vulnerabilities_valid_scores CHECK (
    (impact_score IS NULL OR impact_score BETWEEN 0 AND 10) AND
    (likelihood_score IS NULL OR likelihood_score BETWEEN 0 AND 10) AND
    (cvss_score IS NULL OR cvss_score BETWEEN 0 AND 10)
);

-- SSL certificate constraints
ALTER TABLE public.ssl_certificates 
ADD CONSTRAINT ssl_certificates_valid_dates CHECK (
    valid_from IS NULL OR valid_to IS NULL OR valid_to > valid_from
);

ALTER TABLE public.ssl_certificates 
ADD CONSTRAINT ssl_certificates_valid_port CHECK (
    port BETWEEN 1 AND 65535
);

-- HTTP security analysis constraints
ALTER TABLE public.http_security_analysis 
ADD CONSTRAINT http_security_valid_hsts_age CHECK (
    hsts_max_age IS NULL OR hsts_max_age >= 0
);

-- Vulnerability assignment constraints
ALTER TABLE public.vulnerability_assignments 
ADD CONSTRAINT vulnerability_assignments_valid_due_date CHECK (
    due_date IS NULL OR due_date > created_at
);

-- Remediation constraints
ALTER TABLE public.vulnerability_remediations 
ADD CONSTRAINT vulnerability_remediations_valid_dates CHECK (
    (planned_date IS NULL OR planned_date >= created_at) AND
    (implemented_date IS NULL OR implemented_date >= planned_date) AND
    (verified_date IS NULL OR verified_date >= implemented_date)
);

-- =====================================================
-- FUNCTIONS AND TRIGGERS
-- =====================================================

-- Apply updated_at trigger to relevant tables
CREATE TRIGGER update_vulnerability_types_updated_at 
    BEFORE UPDATE ON public.vulnerability_types
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vulnerabilities_updated_at 
    BEFORE UPDATE ON public.vulnerabilities
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vulnerability_comments_updated_at 
    BEFORE UPDATE ON public.vulnerability_comments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vulnerability_assignments_updated_at 
    BEFORE UPDATE ON public.vulnerability_assignments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vulnerability_remediations_updated_at 
    BEFORE UPDATE ON public.vulnerability_remediations
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_vulnerability_patterns_updated_at 
    BEFORE UPDATE ON public.vulnerability_patterns
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_compliance_frameworks_updated_at 
    BEFORE UPDATE ON public.compliance_frameworks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to calculate vulnerability risk score
DROP FUNCTION IF EXISTS calculate_risk_score(numeric,numeric,numeric);
CREATE OR REPLACE FUNCTION calculate_risk_score(
    impact_score DECIMAL,
    likelihood_score DECIMAL,
    confidence DECIMAL DEFAULT 1.0
)
RETURNS DECIMAL AS $$
BEGIN
    IF impact_score IS NULL OR likelihood_score IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Risk = (Impact × Likelihood × Confidence) / 10
    RETURN ROUND((impact_score * likelihood_score * confidence) / 10, 2);
END;
$$ language 'plpgsql';

-- Function to update vulnerability trends
CREATE OR REPLACE FUNCTION update_vulnerability_trends()
RETURNS TRIGGER AS $$
DECLARE
    project_uuid UUID;
    today_date DATE;
BEGIN
    -- Get project ID from session
    SELECT project_id INTO project_uuid
    FROM public.scan_sessions 
    WHERE id = NEW.session_id;
    
    today_date := CURRENT_DATE;
    
    -- Update or insert trend data
    INSERT INTO public.vulnerability_trends (
        project_id, 
        date_recorded,
        total_vulnerabilities,
        critical_count,
        high_count,
        medium_count,
        low_count,
        info_count
    )
    SELECT 
        project_uuid,
        today_date,
        COUNT(*),
        COUNT(CASE WHEN severity = 'critical' THEN 1 END),
        COUNT(CASE WHEN severity = 'high' THEN 1 END),
        COUNT(CASE WHEN severity = 'medium' THEN 1 END),
        COUNT(CASE WHEN severity = 'low' THEN 1 END),
        COUNT(CASE WHEN severity = 'info' THEN 1 END)
    FROM public.vulnerabilities v
    JOIN public.scan_sessions ss ON v.session_id = ss.id
    WHERE ss.project_id = project_uuid
    ON CONFLICT (project_id, date_recorded) DO UPDATE SET
        total_vulnerabilities = EXCLUDED.total_vulnerabilities,
        critical_count = EXCLUDED.critical_count,
        high_count = EXCLUDED.high_count,
        medium_count = EXCLUDED.medium_count,
        low_count = EXCLUDED.low_count,
        info_count = EXCLUDED.info_count;
    
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger to update vulnerability trends
CREATE TRIGGER update_vulnerability_trends_trigger
    AFTER INSERT OR UPDATE OR DELETE ON public.vulnerabilities
    FOR EACH ROW EXECUTE FUNCTION update_vulnerability_trends();

-- Function to auto-assign severity based on CVSS score
CREATE OR REPLACE FUNCTION auto_assign_severity()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cvss_score IS NOT NULL AND NEW.severity IS NULL THEN
        CASE 
            WHEN NEW.cvss_score >= 9.0 THEN NEW.severity := 'critical';
            WHEN NEW.cvss_score >= 7.0 THEN NEW.severity := 'high';
            WHEN NEW.cvss_score >= 4.0 THEN NEW.severity := 'medium';
            WHEN NEW.cvss_score >= 0.1 THEN NEW.severity := 'low';
            ELSE NEW.severity := 'info';
        END CASE;
    END IF;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger to auto-assign severity
CREATE TRIGGER auto_assign_severity_trigger
    BEFORE INSERT OR UPDATE ON public.vulnerabilities
    FOR EACH ROW EXECUTE FUNCTION auto_assign_severity();

-- =====================================================
-- VIEWS FOR COMMON QUERIES
-- =====================================================

-- Vulnerability summary by project
CREATE VIEW vulnerability_summary AS
SELECT 
    p.id as project_id,
    p.name as project_name,
    COUNT(v.id) as total_vulnerabilities,
    COUNT(CASE WHEN v.severity = 'critical' THEN 1 END) as critical_count,
    COUNT(CASE WHEN v.severity = 'high' THEN 1 END) as high_count,
    COUNT(CASE WHEN v.severity = 'medium' THEN 1 END) as medium_count,
    COUNT(CASE WHEN v.severity = 'low' THEN 1 END) as low_count,
    COUNT(CASE WHEN v.severity = 'info' THEN 1 END) as info_count,
    COUNT(CASE WHEN v.status = 'open' THEN 1 END) as open_count,
    COUNT(CASE WHEN v.verified = true THEN 1 END) as verified_count,
    COUNT(CASE WHEN v.false_positive = true THEN 1 END) as false_positive_count,
    AVG(v.cvss_score) as avg_cvss_score,
    MAX(v.detected_at) as last_vulnerability_date
FROM public.projects p
LEFT JOIN public.scan_sessions ss ON p.id = ss.project_id
LEFT JOIN public.vulnerabilities v ON ss.id = v.session_id
GROUP BY p.id, p.name;

-- Recent vulnerabilities with details
CREATE VIEW recent_vulnerabilities AS
SELECT 
    v.id,
    v.title,
    v.severity,
    v.status,
    v.cvss_score,
    v.detected_at,
    vt.name as vulnerability_type,
    vt.category,
    p.name as project_name,
    du.url,
    creator.username as detected_by
FROM public.vulnerabilities v
JOIN public.vulnerability_types vt ON v.vulnerability_type_id = vt.id
JOIN public.scan_sessions ss ON v.session_id = ss.id
JOIN public.projects p ON ss.project_id = p.id
LEFT JOIN public.discovered_urls du ON v.url_id = du.id
LEFT JOIN public.profiles creator ON ss.created_by = creator.id
ORDER BY v.detected_at DESC;

-- Security metrics by domain
CREATE VIEW security_metrics AS
SELECT 
    du.url,
    regexp_replace(du.url, '^https?://([^/]+).*', '\1') as domain,
    COUNT(v.id) as vulnerability_count,
    AVG(v.cvss_score) as avg_cvss_score,
    hsa.security_score,
    sc.trust_score as ssl_trust_score,
    COUNT(CASE WHEN v.severity = 'critical' THEN 1 END) as critical_vulnerabilities,
    COUNT(CASE WHEN v.severity = 'high' THEN 1 END) as high_vulnerabilities
FROM public.discovered_urls du
LEFT JOIN public.vulnerabilities v ON du.id = v.url_id
LEFT JOIN public.http_security_analysis hsa ON du.id = hsa.url_id
LEFT JOIN public.ssl_certificates sc ON du.id = sc.url_id
GROUP BY du.url, hsa.security_score, sc.trust_score;

-- =====================================================
-- COMMENTS
-- =====================================================

COMMENT ON TABLE public.vulnerability_types IS 'Catalog of vulnerability types and their characteristics';
COMMENT ON TABLE public.vulnerabilities IS 'Vulnerability instances found during scans';
COMMENT ON TABLE public.vulnerability_instances IS 'Detailed instances of vulnerabilities with specific parameters';
COMMENT ON TABLE public.ssl_certificates IS 'SSL/TLS certificate analysis and security assessment';
COMMENT ON TABLE public.dns_records IS 'DNS security analysis and configuration assessment';
COMMENT ON TABLE public.http_security_analysis IS 'HTTP security headers and configuration analysis';
COMMENT ON TABLE public.vulnerability_comments IS 'Comments and notes on vulnerabilities';
COMMENT ON TABLE public.vulnerability_assignments IS 'Vulnerability assignment and ownership tracking';
COMMENT ON TABLE public.vulnerability_remediations IS 'Vulnerability remediation planning and tracking';
COMMENT ON TABLE public.vulnerability_trends IS 'Historical vulnerability trends and metrics';
COMMENT ON TABLE public.vulnerability_patterns IS 'Vulnerability detection patterns and signatures';
COMMENT ON TABLE public.compliance_frameworks IS 'Compliance frameworks and standards';
COMMENT ON TABLE public.vulnerability_compliance IS 'Mapping vulnerabilities to compliance requirements';

COMMENT ON COLUMN public.vulnerabilities.evidence IS 'JSON object containing vulnerability evidence and proof';
COMMENT ON COLUMN public.vulnerabilities.tags IS 'JSON array of vulnerability tags for categorization';
COMMENT ON COLUMN public.vulnerability_instances.request_headers IS 'JSON object with HTTP request headers';
COMMENT ON COLUMN public.vulnerability_instances.response_headers IS 'JSON object with HTTP response headers';
COMMENT ON COLUMN public.ssl_certificates.san_domains IS 'JSON array of Subject Alternative Name domains';
COMMENT ON COLUMN public.ssl_certificates.certificate_chain IS 'JSON array of certificate chain information';
COMMENT ON COLUMN public.dns_records.security_issues IS 'JSON array of identified DNS security issues';

-- =====================================================
-- VERIFICATION QUERIES
-- =====================================================
-- Uncomment these to verify tables were created successfully:

-- SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name LIKE 'vulnerabilit%';
-- SELECT * FROM vulnerability_summary LIMIT 5;
-- SELECT * FROM recent_vulnerabilities LIMIT 5;

-- =====================================================
-- NEXT STEPS
-- =====================================================
-- After running this file successfully:
-- 1. Run 06_reporting_tables.sql for reports and analytics
-- 2. Run 07_integration_tables.sql for notifications and integrations
-- 3. Apply RLS policies with 08_rls_policies.sql
-- 4. Create performance indexes with 09_indexes.sql